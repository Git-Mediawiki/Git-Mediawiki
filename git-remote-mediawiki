#! /usr/bin/perl

use strict;
use Switch;
use MediaWiki::API;
use Storable qw(freeze thaw);
use DateTime::Format::ISO8601;
use Encode qw(encode_utf8);

my $url = $ARGV[1];

print STDERR "$url\n";

# commands parser
my $loop = 1;
my $entry;
my @cmd;
while ($loop) {
	$| = 1; #flush stdout
	$entry = <STDIN>;
	print STDERR $entry;
	chomp($entry);
	@cmd = undef;
	@cmd = split(/ /,$entry);
	switch ($cmd[0]) {
		case "capabilities" {
			if ($cmd[1] eq "") {
				mw_capabilities();
			}
		}
		case "list" {
			if ($cmd[2] eq "") {
				mw_list($cmd[1]);
			} 
		}
		case "import" {
			if ($cmd[1] ne "" && $cmd[2] eq "") {
				mw_import($url);
			} 
		}
		case "option" {
			mw_option($cmd[1],$cmd[2]);
		}
		case "fetch" {
			mw_fetch($url);
		}
		case "push" {
			#check the pattern +<src>:<dist>
			my @pushargs = split(/:/,$cmd[1]);
			if ($pushargs[1] ne "" && $pushargs[2] eq "" 
			&& (substr($pushargs[0],0,1) eq "+")) {	
				print "kikoo";
				mw_push(substr($pushargs[0],1),$pushargs[1]);
			}
		}
		else {
			$loop = 0;
			close(FILE);
		}
	}
}

sub mw_capabilities {
#	print STDOUT "fetch\n";
	print STDOUT "import\n";
	print STDOUT "list\n";
	print STDOUT "option\n";
	print STDOUT "push\n";
	print STDOUT "\n";
}

sub mw_list {
	print STDOUT "? refs/heads/master\n";
#	if ($_[0] eq "") { # call to list and not list for push
	print STDOUT '@'."refs/heads/master HEAD\n";
#	}
	print STDOUT "\n";

}

sub mw_option {
	print STDERR "not yet implemented \n";
	print STDOUT "unsupported\n";
}

sub mw_fetch {
	print "\n";
}

sub mw_import {
	# Fetching revisions from mediawiki 
	my $url = $_[0];

	my $mediawiki = MediaWiki::API->new;
	$mediawiki->{config}->{api_url} = "$url/api.php";

	my $pages = $mediawiki->list({
			action => 'query',
			list => 'allpages',
			aplimit => 500,
		});

	my %revisions;

	print STDERR "Fetching revisions...\n";
	my $n = 1;

	foreach my $page (@$pages) {
		my $id = $page->{pageid};

		print STDERR "$n/", scalar(@$pages), ": $page->{title}\n";
		$n++;

		next if exists $revisions{$id};

		my $query = {
			action => 'query',
			prop => 'revisions',
			rvprop => 'content|timestamp|comment|user|ids',
			rvlimit => 10,
			pageids => $page->{pageid},
		};

		my $page_revisions;
		while (1) {
			my $result = $mediawiki->api($query);

			# Save the result, appending if necessary.
			if (defined $page_revisions) {
				push @{$page_revisions->{revisions}}, @{$result->{query}->{pages}->{$id}->{revisions}};
			} else {
				$page_revisions = $result->{query}->{pages}->{$id};
			}

			# And continue or quit, depending on the output.
			last unless $result->{'query-continue'};
			$query->{rvstartid} = $result->{'query-continue'}->{revisions}->{rvstartid};
		}

		print STDERR "  Fetched ", scalar(@{$page_revisions->{revisions}}), " revisions.\n";
		$revisions{$id} = freeze($page_revisions);

	}

	# Make a flat list of all page revisions, so we can
	# interleave them in date order.
	my @revisions = map {
	my $page = thaw($revisions{$_});
	my @revisions = @{$page->{revisions}};
	delete $page->{revisions};
	$_->{page} = $page foreach @revisions;
	@revisions } keys(%revisions);

	# Creation of the fast-import stream
	print STDERR "Writing export data...\n";
	binmode STDOUT, ':binary';
	$n = 0;
	foreach my $rev (sort { $a->{timestamp} cmp $b->{timestamp} } @revisions) {
		$n++;
		my $user = $rev->{user} || 'Anonymous';
		my $dt = DateTime::Format::ISO8601->parse_datetime($rev->{timestamp});
		#TODO: Write empty message ?
		my $comment = defined $rev->{comment} ? $rev->{comment} : '';
		my $title = $rev->{page}->{title};
		my $content = $rev->{'*'};
		$title =~ y/ /_/;

		print STDERR "$n/", scalar(@revisions), ": $rev->{page}->{title}\n";
		
		print "commit refs/heads/master\n";
		print "mark :$n\n";
		print "committer $user <none\@example.com> ", $dt->epoch, " +0000\n";
		print "data ", bytes::length(encode_utf8($comment)), "\n", encode_utf8($comment);
		print "M 644 inline $title.wiki\n";
		print "data ", bytes::length(encode_utf8($content)), "\n", encode_utf8($content);
		print "\n\n";

	}

	print "reset refs/heads/master\n";
	print "from :$n \n\n";

}

sub mw_push {
	print STDERR "not yet implemented \n";
}


1;
